### 평가

- 코드가 계산되어 값을 만드는 것

### 일급

- 값으로 다룰 수 있다
- 변수에 담을 수 있다
- 함수의 인자로 사용될 수 있다.
- 함수의 결과로 사용될 수 있다.

### 일급함수

- 값으로 다뤄지는 함수
- 조합성과 추상화의 도구

### 고차함수

- 함수를 값으로 다루는 함수
- 함수, 즉 코드를 값으로 다룬다는 것은 인자로 전달 받은 **함수가 평가될 시점을 원하는 대로 조정할 수 있다는 것!**

# 리스트 순회

- for in 문은 Object 객체의 '열거가능한'([[Prototype]]에 연결된 프로퍼티까지도)프로퍼티를 순회
- for of 문은 이터러블 객체를 순회

## 이터러블/이터레이터 프로토콜

- 이터러블/이터레이터 프로토콜 : 이터러블을 for of, 전개 연산자 등과 함께 동작하도록 정한 규약
  (즉, for of문과 전개 연산자는 내부적으로 이터레이터를 호출한다)

- Map과 Set도 이터러블 프로토콜을 준수하는 객체이다.

### 이터레이터

- 순회하기 위한 **next메소드를 프로퍼티로 가지는 객체**

- 이 next메소드는 반드시 { value, done } 객체를 반환해야 한다.

- value 프로퍼티는 순회에 사용되는 값이고,

- done 프로퍼티는 순회 여부를 결정하기 위한 값이기 때문.

- 이 이터레이터는 이터러블의 [Symbol.iterator]메소드를 호출했을 때 반환 받는 값이다.

### 이터러블

- 이터레이터를 반환하는 **[Symbol.iterator]메소드를 프로퍼티로 가지는 객체**

### well-formed 이터레이터

- 순회하기 위한 next메소드와 **자기 자신(this)을 반환하는 [Symbol.iterator]메소드**를 프로퍼티로 가지는 객체

- 즉, 이터레이터면서 동시에 이터러블이면 well-formed이터레이터라고 한다.

# 제너레이터

- 제너레이터는 well-formed 이터레이터를 반환하는 함수

- yield가 반환하는 값이 다음 순회(next)에서 반환하는 value값이다.

- 제너레이터 함수에서는 return문의 작성이 선택적인데, 작성할 경우 순회의 종료를 의미하며

- return이 반환하는 값이 value로, done은 true로 설정된다.

- 함수형 프로그래밍의 맥락에서 제너레이터는 순회할 값을 만드는 함수이다
  (원래 제너레이터의 핵심은 제어권 양도인 것으로 알고 있음)

- 제너레이터를 통해 사실상 모든 형태의 값을 순회할 수 있게끔 만들 수 있음
  (=다형성이 높음)

### DRY(Don't Repeat Yourself)

- 일련의 함수조합(map=>filter=>reduce)중 중복되는 것이 있다면, compoundFunctions를 사용하여 고차함수를 만들어서 중복을 줄일 수 있다.
  (=추상화 레벨을 높인다)
  `

### 지연 평가(Lazy evaluation)

- ~~Lazy의 어감이 와 닿지 않아서 내 파일에서는 Reserve(평가를 유보한다는 의미로)로 대체하였다.~~

- 순회할 값들을 미리 평가해놓는 것이 아니라 매 순회(next())마다 해당하는 값을 평가하여, 연산에 불필요한 값은 평가하지 않는 개념

- 제너레이터/이터레이터가 있기에 가능한 개념

### map, filter계열 함수들이 가지는 결합 법칙

- 사용하는 데이터가 어떤 종류의 것이든지

- 사용하는 보조 함수가 순수 함수라면 무엇이든지
  (순수 함수 : 인자값을 변화시키지 않는 함수)

- 즉시 평가와 지연 평가의 결과가 같다

### 결과를 만드는 함수인 reduce와 max

- map과 filter가 이터러블한(모나딕한) 값의 원소들에게 함수를 합성하는 역할을 하는 반면,
  (즉 이터러블의 형태를 유지하는, 지연성을 가지고 있음)

- reduce나 max같은 함수의 경우 이터러블의 포맷을 깨고 결과를 반환하는 함수이다.

- max도 지연성을 가진다고 볼 수도 있지만, 원소 값이 몇 개가 될 지 모르는 배열을
  특정 개수의 원소를 가진 배열로 '완성'시킨다는 점에서 결과를 만드는 함수라고 본다.

### Promise

- 프라미스는 (pending, fulfilled, rejected)라는 비동기 상황 자체를 일급 값으로 다룬다!

- 비동기 상황에서 함수 합성을 안전하게 하는 도구(모나드)

### 모나드

- 함수 합성을 안전하게 하기 위한 도구

- 현실 프로그래밍 세계에서는 우리가 합성한 함수에 어떤 형태의 값이 들어올 지 장담할 수 없다.

- 자바스크립트에서는 Array라는 컨테이너에서 메소드를 적용하는 것이 이런 모나드의 예가 될 수 있다.
  (=잘못된 값이 들어왔을 때의 side effect를 예방할 수 있다)

### Kleisli Composition

- 오류가 있을 수 있는 상황에서 함수 합성을 안전하게 할 수 있도록 하는 규칙

- 예를 들어, 함수 f와 g를 합성했다고 가정해보자.

- 그러면 f(g(x))와 같이 합성이 되는데, 이 중 g에서 오류가 날 수 있다.

- 그랬을 때, f(g(x))가 g(x)와 결과가 같도록 합성하는 것이 Kleisli Composition이다.
  (현실 프로그래밍에서는 외부 세계의 영향을 받기 때문에 f(g(x)) === f(g(x))가 시간 등의 외부 요인에 따라 항상 성립하지 않을 수 있기 때문에 필요한 개념이다)

- Promise는 Kleisli Composition을 지원하는 도구이다.
